#ifndef EIGEN_INC_HPP
#define EIGEN_INC_HPP


#ifndef STL_INC_HPP
#define STL_INC_HPP
#include <STL_INC.hpp>
#endif

#define EIGEN_VECTORIZE
#define EIGEN_DEFAULT_TO_ROW_MAJOR
#define EIGEN_HAVE_RVALUE_REFERENCES

#include <Eigen/Core>
#include <Eigen/Dense>
#include<Eigen/StdVector>

// DEFINE STORAGE ORDERS
#define C_Contiguous Eigen::RowMajor
#define F_Contiguous Eigen::ColMajor
// GENERIC ALIGNED
#define POSTMESH_ALIGNED C_Contiguous


// DYNAMIC MATRICES
#define DYNAMIC Eigen::Dynamic


// FOR EIGEN WRAPPER
//#define MAP_DATA // DEFAULT, NOT USED
//#define WRAP_DATA // UNCOMMENT THIS IF YOU WANT TO WRAP THE DATA

namespace Eigen {
// DEFINE Real, Integer AND UInteger BASED MATRICES
typedef Eigen::Matrix<Real,DYNAMIC,DYNAMIC,POSTMESH_ALIGNED> MatrixR;
typedef Eigen::Matrix<Integer,DYNAMIC,DYNAMIC,POSTMESH_ALIGNED> MatrixI;
typedef Eigen::Matrix<UInteger,DYNAMIC,DYNAMIC,POSTMESH_ALIGNED> MatrixUI;


#ifdef WRAP_DATA
// AN EIGEN MATRIX WRAPPER OVER RAW BUFFERS (WHILE USING THIS WRAPPER
// TO WRAP C-STYLE POINTERS DO NOT FREE THE MEMORY OWNED BY THE POINTER
// EXPLICITLY, AS THE OWNERSHIP IS TRANSFERRED TO EIGEN MATRIX AND HENCE
// EIGEN TAKES CARE OF DESTRUCTION, OTHERWISE YOU WILL END UP WITH DOUBLE
// FREE CORRUPTION ISSUE)
template<typename T> struct WrapRawBuffer {
    // NOTE THAT THIS WRAPPER TRANSFERS OWNRSHIP OF THE DATA SO
    // ANY RESOURCE MANAGING CLASS LIKE SHARED_PTR, UNIQUE_PTR,
    // STD::VECTOR OR EIGEN MATRIX WILL DELETE THE DATA

    // THIS IS JUST TO USE AN EXISTING PIECE OF MEMORY AND TRANSFER
    // IT TO EIGEN MATRIX WITHOUT MAKING COPIES. EIGEN DOES NOT PROVIDE
    // A WRAPPER OVER RAW BUFFERS AND PROBABLY NEVER WILL BECAUSE OF ABI
    // COMPATIBILITIES AND API CONSISTENCY.

    // DO NOT USE THIS WRAPPER IF THE DATA IS USED (OR BELONGS TO) THE
    // OUTSIDE WORLD (BEYOND THE TRANSLATION UNITS THAT IMPORT THIS),
    // FOR INSTANCE IF THE DATA IS COMMING FROM PYTHON NUMPY ARRAYS

    // WITH POSTMESH MEMBER DATA THIS WRAPPER HAS TO BE USED IN
    // CONJUNCTION WITH MOVE SEMANTICS

    T* data;
    Eigen::DenseIndex rows, cols;
    Eigen::Matrix<T, DYNAMIC, DYNAMIC, POSTMESH_ALIGNED>& asPostMeshMatrix(){
        return reinterpret_cast<Eigen::Matrix<T, DYNAMIC,
                DYNAMIC, POSTMESH_ALIGNED>&>(*this);
  }
  // NO DESTRUCTOR NEEDED, AS THEN WE WILL FREE THE MEMORY MORE THAN ONCE
//  ~WrapRawBuffer(){delete data;}
};
#endif

}


#endif // EIGEN_INC_HPP

